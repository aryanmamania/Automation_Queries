#!/usr/bin/env python3
import imaplib
import email
import re
import subprocess
import os
import tempfile
import smtplib
import time
from email.header import decode_header
from email.message import EmailMessage
from email.utils import parseaddr

EMAIL = 'aryan.mamania@fosteringlinux.com'
PASSWORD = 'ftng tlhy hycc olcv'
IMAP_SERVER = 'imap.gmail.com'
SMTP_SERVER = 'smtp.gmail.com'
SMTP_PORT = 465
IMAP_FOLDER = 'INBOX'
ALLOWED_SUBJECT = "Execute the query Luffy"

def decode_mime_words(s):
    decoded = decode_header(s)
    return ''.join([str(t[0], t[1] or 'utf-8') if isinstance(t[0], bytes) else t[0] for t in decoded])

def get_unread_emails():
    print("[*] Connecting to mail server...")
    mail = imaplib.IMAP4_SSL(IMAP_SERVER)
    mail.login(EMAIL, PASSWORD)
    mail.select(IMAP_FOLDER)
    typ, data = mail.search(None, '(UNSEEN SUBJECT "Execute the query Luffy")')
    mail_ids = data[0].split()
    print(f"[*] Found {len(mail_ids)} unread emails.")

    messages = []
    for num in mail_ids[-10:]:
        typ, msg_data = mail.fetch(num, '(RFC822)')
        for response_part in msg_data:
            if isinstance(response_part, tuple):
                msg = email.message_from_bytes(response_part[1])
                subject = decode_mime_words(msg["Subject"])
                sender = parseaddr(msg["From"])[1]
                message_id = msg["Message-ID"]
                body = ""
                if msg.is_multipart():
                    for part in msg.walk():
                        content_type = part.get_content_type()
                        content_disposition = str(part.get("Content-Disposition"))
                        if content_type == "text/plain" and "attachment" not in content_disposition:
                            try:
                                body += part.get_payload(decode=True).decode(errors="ignore")
                            except Exception as e:
                                print(f"[!] Error decoding part: {e}")
                else:
                    try:
                        body = msg.get_payload(decode=True).decode(errors="ignore")
                    except Exception as e:
                        print(f"[!] Error decoding message: {e}")
                messages.append((subject, sender, message_id, body))
    return messages

def clean_insert_query(query: str) -> str:
    matches = re.findall(r"\(\s*'([^']*)'\s*,\s*'([^']*)'\s*\)", query)
    cleaned_values = []
    for name, email_val in matches:
        cleaned_values.append(f"('{name.strip()}', '{email_val.strip()}')")
    prefix_match = re.match(r"(?i)^(INSERT INTO\s+[^\(]+\([^)]+\)\s+VALUES\s*)", query.strip(), re.DOTALL)
    if prefix_match:
        return prefix_match.group(1) + ",\n".join(cleaned_values) + ";"
    return query

def extract_query_info(body):
    # Extract DB name
    db_match = re.search(r'Database:\s*(\w+)', body, re.IGNORECASE)
    db = db_match.group(1).strip() if db_match else None

    # Extract entire "Query:\n<everything until end or next header>"
    query_match = re.search(r'Query:\s*\n(.+)', body, re.IGNORECASE | re.DOTALL)
    if not query_match:
        return None, None

    raw_query = query_match.group(1).strip()

    # Strip any common footers
    footer_patterns = ['Thanks', 'Regards', '--']
    for footer in footer_patterns:
        raw_query = raw_query.split(footer)[0]

    # Clean up extra whitespace
    cleaned_query = raw_query.strip()

    return db, cleaned_query


def run_query_with_ansible(db, query):
    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=".sql") as tmp:
        tmp.write(query)
        sql_file_path = tmp.name

    try:
        cmd = (
            f"ansible-playbook -i hosts.ini playbooks/run_query.yml "
            f"--extra-vars db_name='{db}' "
            f"--extra-vars sql_file='{sql_file_path}'"
        )
        print(f"[*] Running Ansible: {cmd}")
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

        match = re.search(r'"msg":\s*"((?:\\.|[^"\\])*)"', result.stdout, re.DOTALL)
        if match:
            raw_msg = match.group(1)
            output = bytes(raw_msg, "utf-8").decode("unicode_escape").strip()
        else:
            output = result.stdout.strip()

        is_select = query.strip().lower().startswith("select")
        if is_select:
            inner_result = re.search(r"Result:\s*(.*)", output, re.DOTALL)
            return inner_result.group(1).strip() if inner_result else "Query executed. No rows returned."
        else:
            row_match = re.search(r'(\d+) row\(s\) affected', output)
            if row_match:
                return f"{row_match.group(1)} row(s) affected."
            return "Query executed. No rows returned or affected."
    finally:
        if os.path.exists(sql_file_path):
            os.remove(sql_file_path)

def send_reply_email(to_address, original_subject, query, output, original_msg_id=None):
    msg = EmailMessage()
    msg["From"] = EMAIL
    msg["To"] = to_address
    msg["Subject"] = f"Re: {original_subject}"
    if original_msg_id:
        msg["In-Reply-To"] = original_msg_id
        msg["References"] = original_msg_id

    msg.set_content(f"""\
Your query has been executed.

Database: {query['db']}
Query:
{query['sql']}

Result:
{output}
""")

    with smtplib.SMTP_SSL(SMTP_SERVER, SMTP_PORT) as smtp:
        smtp.login(EMAIL, PASSWORD)
        smtp.send_message(msg)
        print(f"[+] Sent reply to {to_address}")

if __name__ == "__main__":
    print("[*] Starting email monitoring loop...")
    while True:
        try:
            messages = get_unread_emails()
            for (subject, sender_email, msg_id, msg_body) in messages:
                if subject.strip() != ALLOWED_SUBJECT:
                    continue

                print(f"[+] Found matching email: '{subject}' from {sender_email}")
                db, query = extract_query_info(msg_body)
                if db and query:
                    print(f"[+] Found query for DB `{db}`:\n{query}")
                    try:
                        result_output = run_query_with_ansible(db, query)
                        send_reply_email(
                            to_address=sender_email,
                            original_subject=subject,
                            query={'db': db, 'sql': query},
                            output=result_output,
                            original_msg_id=msg_id
                        )
                    except subprocess.CalledProcessError as e:
                        print(f"[!] Ansible failed: {e}")
                else:
                    print("[*] No valid query found in this email.")
        except Exception as e:
            print(f"[!] Unexpected error: {e}")

        time.sleep(60)
